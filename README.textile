Psttt! is kind of a template engine but it does not alter original html files it just uses original mockups from the initial development stage, allowing continuous mockup development and leaving front end developers and programmers living in peace by excluding the possibility to step on each others toes.

How to achieve this?
1 The solution is simple, keep template logic out of the html files, they don't belong there.
 Psttt! uses separate files to keep template logic
2 Make it extremly easy to inject logic into the html.
 Psttt! uses css selectors to determine where to inject pieces of template logic.
Enough talking, let me show you some snippets to get a better view.
The simplest and dumbest example:
**html mockup**


h1. Write our company name here
</pre>

**php code**

<pre>
$view->title = 'Foo company';
</pre>

**psttt! code**

<pre>
h1#title = $title;
</pre>

**resulting php code**

<pre>
h1. 
</pre>


Not convincing enough isn't it? just showing you the separate layers, let's move on to some more realistic examples like a shoping cart product list page, a very common pattern.

**html mockup**



    
h2. Mockup product 1
!!
Some product description goes here!
%Price: *99999*%

    
h2. Mockup product2
!!
Some product description goes here!
%Price: *888.99*%


</pre>

**php code**

p(=syntax). 
$view->products = array(
    1 => array('title'=> 'Product 1', 'img' => '/img/products/1.jpg' , 'description' => 'the best product ever', price => '$10'),
    2 => array('title'=> 'Product 2', 'img' => '/img/products/2.jpg' , 'description' => 'the second best product ever', price => '$30')
);
</pre>

**psttt! code**

<pre>
//we just need one product to fill in data and iterate
#product_list>.product|deleteAllButFirst
//add iteration code, php foreach that will fill in data
#product_list>.product|before = 
    #product_list > .product> h2 = $product[title]
    #product_list >  .product > img|src = $product[img]
    #product_list > .product > p = $product[description]
#product_list > .product > .span > strong = $product[price]
#product_list>.product|after = 
</pre>

**resulting php code**

<pre>

    Welcome *Demo user 1*



    
h2. 
!!"/>

%Price: **%



</pre>


Maybe you are not convinced and you say to yourself that you can add that php code directly into the html or add some smarty or other template engine syntax and that this is not such a big deal.
And that is an overhead to maintain a different file and keep these things separate.


If so then think what happens when the front end developer changes the layout even if a little bit after you wrote your templates and added lots of divs in all over the places and you have to follow all your template includes and change all that, I know, it sucks and it's very time consuming.


With Psttt! when the developer changes the layout you don't have to change anything you already wrote, the logic for the html file that will be automatically be injected in his new html files.
That's the power of keeping things clean and separated, no more html + logic hard to maintain bloat, that just doesn't cut it in an continuous changing living and breathing website.


"Psttt! full documentation":http://codeassembly.com/Psttt!-full-documentation/, full source code with examples can be found on "github":http://github.com/givanz/psttt	
Psttt! I am a different php templating system

Psttt! is kind of a template engine but it does not alter original html files it just uses original mockups from the initial development stage, allowing continuous mockup development and leaving front end developers and programmers living in peace by excluding the possibility to step on each others toes.


How to achieve this?

Keep template logic out of the html files, they don't belong there.
 Psttt! uses separate files to keep template logic


Make it extremly easy to inject logic into the html.
 Psttt! uses css selectors to determine where to inject pieces of template logic.



Enough talking, let me show you some snippets to get a better view.
The simplest and dumbest example:
**html mockup**


<h1 id='title'>Write our company name here</h1>
</pre>

**php code**

<pre>
$view->title = 'Foo company';
</pre>

**psttt! code**

<pre>
h1#title = $title;
</pre>

**resulting php code**

<pre>
<h1 id=?title?><?php echo $this->title;?></h1>
</pre>


Not convincing enough isn't it? just showing you the separate layers, let's move on to some more realistic examples like a shoping cart product list page, a very common pattern.

**html mockup**


<div id='product_list'>
    <div class='product'>
<h2>Mockup product 1</h2>
<img src='/images/default_product1.jpg'/>
<p>Some product description goes here!</p>
<span>Price: <strong>99999</strong></span>
</div>
    <div class='product'>
<h2>Mockup product2</h2>
<img src='/images/default_product2.jpg'/>
<p>Some product description goes here!</p>
<span>Price: <strong>888.99</strong></span>
</div>
</div>
</pre>

**php code**

<pre class="syntax">
$view->products = array(
    1 => array('title'=> 'Product 1', 'img' => '/img/products/1.jpg' , 'description' => 'the best product ever', 'price' => '$10'),
    2 => array('title'=> 'Product 2', 'img' => '/img/products/2.jpg' , 'description' => 'the second best product ever', 'price' => '$30')
);
</pre>

**psttt! code**

<pre>
//we just need one product to fill in data and iterate
#product_list>.product|deleteAllButFirst
//add iteration code, php foreach that will fill in data
#product_list>.product|before = <?php if ($this->products) foreach($this->products as $product    ):?>
    #product_list > .product> h2 = $product[title]
    #product_list >  .product > img|src = $product[img]
    #product_list > .product > p = $product[description]
#product_list > .product > .span > strong = $product[price]
#product_list>.product|after = <?php endforeach;?>
</pre>

**resulting php code**

<pre class="syntax">
<div class=?user_box?>
    Welcome <strong class=?username?>Demo user 1</strong>
</div>
<div id=?product_list?>
<?php if ($this->products) foreach($this->products as $product):?>
    <div class=?product?>
<h2><?php echo  $product[title];?></h2>
<img src=?<?php echo  $product[img];?>?/>
<p><?php echo  $product[description];?></p>
<span>Price: <strong><?php echo  $product[price];?></strong></span>
</div>
<?php endforeach;?>
</div>
</pre>


Maybe you are not convinced and you say to yourself that you can add that php code directly into the html or add some smarty or other template engine syntax and that this is not such a big deal.
And that is an overhead to maintain a different file and keep these things separate.


If so, then think what happens when the front end developer changes the layout even if a little bit after you wrote your templates and he added lots of divs in all over the places and you have to follow all your template includes and change all that, I know, it sucks and it's very time consuming.


With Psttt! when the developer changes the layout you don't have to change anything you already wrote, the logic for the html file that will be automatically be injected in his new html files.
That's the power of keeping things clean and separated, no more html + logic hard to maintain bloat, that just doesn't cut it in an continuous changing living and breathing website.




h1. Documentation


Psttt! is just a list of key = value pairs.
On the left you need to specify the CSS selector and on the right the code that must be injected for the selector.
The code to be injected can be one of the following

h2. simple strings

p(=syntax). 
div#id > span.class a = "lorem ipsum"

</pre>
h2. php variables

<pre class="syntax">
div#id > span.class a = $variable

</pre>
h2. Php code for complex logic

<pre class="syntax">
div#id > span.class a = 

</pre>
h2. External html includes, "from"

<pre class="syntax">
/*
from, a special command that copies html from other templates, useful to include up to date html code into all templates from the currently maintained template for the specified section
*/
div#top > div.header = from(homepage.html|div#top > div.header)
/*
Or you can skip the selector part, in this case the same selector is assumed.
*/
div#top > div.header = from(homepage.html)

</pre>
h2. List of modifiers
h3. outerHTML

<pre class="syntax">
/*
by default code is injected into the specified elements without replacing the elements (innerHTML) to replace the entire elements with the specified code use outerHTML modifier
*/
div#id > span.class a|outerHTML = "lorem ipsum"
/*
now the entire "": will be replaced with "lorem ipsum" text instead of the default behaviour of inserting the text like this "lorem ipsum":
*/

</pre>
h3. before

<pre class="syntax">
/*
Inserts the code before the elements
*/
div#id > span.class a|outerHTML = "lorem ipsum"
/* this will result in "lorem ipsum"":"

</pre>
h3. after

<pre class="syntax">
/*
Inserts the code after the elements
*/
div#id > span.class a|outerHTML = "lorem ipsum"
/* this will result in """:lorem ipsum"

</pre>
h3. deleteAllButFirst

<pre class="syntax">
/* Deletes all elements for the specified selector except for the first elements, usually in mockups front end developers add multiple elements to better show the final page look, the programmer just needs one element to iterate and fill data*/
div#id > span.class a|deleteAllButFirst
/*
this

%
"link 1":
"link 2":
"link 3":
%
 span.class a = $variable
</pre>

h2. Php code for complex logic

<pre>
div#id > span.class a =  <?php if ($var) echo ?some text?;?>
</pre>

h2. External html includes, "from"

<pre>
/*
from, a special command that copies html from other templates, useful to include up to date html code into all templates from the currently maintained template for the specified section
*/
div#top > div.header = from(homepage.html|div#top > div.header)
/*
Or you can skip the selector part, in this case the same selector is assumed.
*/
div#top > div.header = from(homepage.html)
</pre>

h2. List of modifiers
h3. outerHTML

<pre>
/*
by default code is injected into the specified elements without replacing the elements (innerHTML) to replace the entire elements with the specified code use outerHTML modifier
*/
div#id > span.class a|outerHTML = "lorem ipsum"
/*
now the entire "": will be replaced with "lorem ipsum" text instead of the default behaviour of inserting the text like this "lorem ipsum":
*/
</pre>

h3. before

<pre>
/*
Inserts the code before the elements
*/
div#id > span.class a|outerHTML = "lorem ipsum"
/* this will result in "lorem ipsum"":"

</pre>
h3. after

<pre>
/*
Inserts the code after the elements
*/
div#id > span.class a|outerHTML = "lorem ipsum"
/* this will result in """:lorem ipsum"
</pre>

h3. deleteAllButFirst

<pre>
/* Deletes all elements for the specified selector except for the first elements, usually in mockups front end developers add multiple elements to better show the final page look, the programmer just needs one element to iterate and fill data*/
div#id > span.class a|deleteAllButFirst
/*
**this**
<div id=?id?>
<span class=?class?>
<a>link 1</a>
<a>link 2</a>
<a>link 3</a>
</span>
</div
**wil result into this**
<div id=?id?>
<span class=?class?>
<a>link 1</a>
</span>
</div>
*/
</pre>

h3. hide

<pre>
/*removes the specified elements if the variable is false*/
div.articles|if_exists = $articles
</pre>

h3. delete

<pre>
/* removes the specified elements*/
div.articles|delete
</pre>

h3. outerHTML

<pre>
attributes
/*
to inject code into a tag's attribute you must specify the attribute as an modifier
*/
div#id > span.class a|href = "www.thewebsite.com"
</pre>

h2. additional commands
h3. import

<pre>
import(profile/activity_tab.pst)
</pre>


includes additional files, usefull to separate logic when things get bigger and harder to maintain in one file

h2. Comments